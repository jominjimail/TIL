# 부스트 캠프 멤버십 27일차 

## week6 front-end day1

### 오늘 공부한거 

#### Observer Pattern 

목적 : 모듈간의 의존성을 낮추기 위해

> A,B,C 모듈이 있다고 하자. 
>
> A 모듈에서는 어떠한 경우에 '데이터 추가'라는 이벤트가 발생한다. B와 C는  '데이터 추가' 이벤트가 발생하면 본인들의 어떤 상태를 변경해줘야 한다. 따라서 B와 C는 '데이터추가' 라는 이벤트를 주시해야 하는 입장이다. 하지만 언제 '데이터 추가' 이벤트가 발생할 지는 모른다. 따라서 B와 C는 '데이터추가' 이벤트를 구독하는 것이 좋은 방법이다. 여기서 주의할 점은, '데이터 추가'를 구독하는것이지 'A의 데이터추가'를 구독하는 것이 아니라는 점이다. 실제로 B와 C의 관심은 '누가 발생시킨 이벤트인가?' 가 아니고, '어떤 이벤트가 발생했는가?' 이다.

#### Observable (Subject)

- 상태가 변경될 대상
- subscribe, unsubscribe, notify 행동을 처리하는 메서드 필요
- **Model**
- 상태가 변경되면 notify를 통해 구독자들에게 알려준다. (바꼈어요~)
- Observable 클래스는 구독자들을 관리하는 this._observers 리스트가 있다.

#### Observer(구독자)

- 상태 변화를 감지하는 대상

- Observer에 등록할 수 있는 건 함수, 객체 모두 가능.

- **View**

- 변화가 감지되면 뷰의 뭔가가 작동된다. 뭔가는 함수가 될 수도 있고 객체가 될 수도 있고 뭐든 된다.

- 뷰의 뭔가는 Observable의 subscribe에 미리 등록되어 있다.

- observer는 얻으려는 데이터를 pull 방식이 아니라 push 방식으로 얻을 수 있다. 

- 등록하고 정보만 받아본다. 구독하고 notify만 받는다. 

- observable의 구독자 리스트에 뭔가를 등록하고 notify가 되면 등록된 무언가가 실행된다. 

- View는 이벤트를 구독 (구독자 리스트에 등록) 할 수 있지만, 단 방향 흐름에 따라 '상태'를 구독할 수 있다. 

  > unidirectional data flow : Observale => Observer

- Model은 notify 발행하고 View는 구독하는 관계임을 알 수 있다. 

- View는 Model을 구독한다 == 변화를 감지한다 == 변화를 알 고 싶다 == notify를 받고 싶다 == 알려줬으면 좋겠다

#### 결론

'이벤트' => 상태변경(Model) => 화면의변화(View)

Model이 Observable이 되고, View가 Observer가 된다. 

#### 다음 할 일 

본인이 진행하는 서비스 코드에 이 부분을 어디에 적용해야할지 고민해본다.

### 오늘 개발한거 

### 오늘 느낀점 

어렵다. 
